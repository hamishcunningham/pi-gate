Packaging Software for the Pi

_Packaging and distributing software for the Pi_
%meta(summary=Packaging and distributing software for the Pi)

_%(about.html#hamish, Hamish Cunningham), October 2013_

-----------------------------------------------------------------------------
%%% TODO
%1* DRAFT, unfinished
-----------------------------------------------------------------------------

%contents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Introduction: the Good Old Days

Twenty-odd years ago I worked for a company building accounting and stock
control systems for manufacturing businesses. I started as a general gopher,
tea-maker and minor bug fixer on big old behemoths written in a language
called COBOL -- which some people claimed was a "common business-oriented
language" but I was sure stood for "computer operators are boring and
obviously lobotomised". Customers would phone up and say "we've got a new
invoice format, can you change the report printer to fit?", and I would spend
a day or two hunched over a stack of continuous paper (the type with
%br %(http://en.wikipedia.org/wiki/File:Bound_computer_printout.agr.jpg,
%image(images/continuous-paper.jpg, Old-style printer paper, 408, 599)) %br
perforated edges) with a special measuring ruler figuring out how many spaces
to leave between the date and the address, and the like.

The low point of this phase was four days of my life spent chasing a rounding
error in an invoicing program that resulted in a 2 pence error on a Â£10,000
invoice. I told the boss that I was happy to pay them the 2 pence every time
it happenned if only I could stop leafing through that 100-page COBOL
monstrosity%footnote(The program is engraved on my soul -- it was called
SOP-1, for Sales Order Processing, and it had grown and grown far beyond the
ability of a neophyte like myself to ever understand. Trial and error was my
only weapon, and it was a definite trial with lots of errors.), but he didn't
think that was a great customer relations strategy.

The company was starting to move into Unix-based delivery platforms (System V
was the new thing back then; and a whole business would run on a tiny
mini-computer!). I was lucky enough to get my hands dirty with the new
technology, and learnt an awful lot in short space of time. It is a testament
to the power and success of the Unix paradigm that I'm still using many of
these skills today -- C programming, shell scripting, systems administration
and the like.

One of my tasks at the time was to package and distribute versions of our
systems to customer machines. I used a program called UUCP (Unix-to-Unix copy)
over dial-up modem links to push new updates onto machines out on site (and,
cheekily, used to get the customer machine to phone us back so that the
lengthy upload process would happen on their phone bill, not ours!). Things
are a little simpler now: someone invented a thing called the
Internet...%footnote(The Internet, of course, mostly runs on Unix-based
operating systems, as does your Pi, Android phones, and Apple computers.)

The job of packaging and distribution continues to be important, though, and
below I'll describe the mechanisms used for the Raspberry Pi's _Raspbian_
operating system.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 The Problem

Software packaging and distribution has to deal with versions, dependencies
and access:

- Different _versions_ of programs can incorporate lots of changes, including
  critical security fixes that need applying in a hurry. Especially on older
  systems and in low-bandwidth locations, minimising the amount of new
  download for a changed version is important.
- _Dependencies_ between programs are often tied to particular versions -- if
  a function that one program relies on changes, its package data must reflect
  its need for the old version.
- _Access_ to packages is relatively easy now -- most software is distributed
  as a network download. But what happens if the connection drops half-way
  through? Or if a million people all want updates on the same day?

These issues have been addressed in various ways; one of the most succesful
and wide-reaching is the Debian package management system, and this is the one
that we'll describe here.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 The Platform: GNU, Linux, Debian, Raspbian and Ubuntu

%(http://www.debian.org/, Debian) is a _distribution_ of %(http://www.gnu.org/,
GNU) %(http://www.linuxfoundation.org/, Linux), which is a Unix-like
operating system (like Android, MacOS, Ubuntu, Red Hat and many others). For
the Pi there's a special version of Debian called %(http://www.raspbian.org/,
Raspbian).

Probably the most popular version of Linux at present is
%(http://www.ubuntu.com/, Ubuntu), but because of an incompatibility between
the Pi's version of its %(http://en.wikipedia.org/wiki/ARM_architecture, ARM
microprocessor) and the Ubuntu build system, we can't use Ubuntu's
infrastructure on the Pi, except for programs which are _architecture
independent_ -- a term which we'll explain below when we show how to use
Ubuntu Personal Package Archives for Pi software distribution.


%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% %2 GNU and Linux
%%% 
%%% TODO
%%% 
%%% 
%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% %2 Old and New: Debian and Raspbian
%%% 
%%% TODO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Ubuntu's Personal Package Archives

Broadly speaking, computer programming languages come in two sorts: _compiled_
or _interpreted_. Compiled languages are translated into machine code (binary
instruction sequences) before they can be run. Interpreted languages can be
run directly without any translation. This means that programs written in
interpreted languages are often _architecture independent_ -- they can run
without change on many different types of computer chips. Several languages
popular on the Pi fall into this category, including Shell Script and (with
some restrictions) Python.

As we noted earlier, Ubuntu Linux is very popular (and is also derived from
Debian). Ubuntu has a great set of infrastructure tools associated with it,
including _Personal Package Archives_ (PPAs) which simplify the task of
building, packaging and distributing software for all the platforms supported
by Ubuntu. If we're packaging an architecture-independent program, then, a PPA
can be a good way to distribute it. (Several Pi GATE programs are
%(download.html, distributed like this).)

Linux is %(http://www.fsf.org/about/what-is-free-software, open source free
software), and to make sure everyone gets access to the source of programs in
PPAs, Ubuntu only accepts Debian _source packages_ as uploads to the archives.
This means we have to build both a _source_ (^.dsc^) and a _binary_ (^.deb^)
package for each program; the next section describes how we do this.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Debian Packaging

      - seeding the package: dh\_make -p=simbamond\_1.0 --native


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Case Studies

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 SimBaMon and BlinkIP

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 WiringPi
