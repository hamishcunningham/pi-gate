Packaging Software for the Pi

_Packaging and distributing software for the Pi_
%meta(summary=Packaging and distributing software for the Pi)

_%(about.html#hamish, Hamish Cunningham), October 2013_

-----------------------------------------------------------------------------
%%% TODO
%1* DRAFT, unfinished
-----------------------------------------------------------------------------

%contents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Introduction: the Good Old Days

Twenty-odd years ago I worked for a company building accounting and stock
control systems for manufacturing businesses. I started as a general gopher,
tea-maker and minor bug fixer on big old behemoths written in a language
called COBOL -- which some people claimed was a "common business-oriented
language" but I was sure stood for "computer operators are boring and
obviously lobotomised". Customers would phone up and say "we've got a new
invoice format, can you change the report printer to fit?", and I would spend
a day or two hunched over a stack of continuous paper (the type with
%br %(http://en.wikipedia.org/wiki/File:Bound_computer_printout.agr.jpg,
%image(images/continuous-paper.jpg, Old-style printer paper, 408, 599)) %br
perforated edges) with a special measuring ruler figuring out how many spaces
to leave between the date and the address, and the like.

The low point of this phase was four days of my life spent chasing a rounding
error in an invoicing program that resulted in a 2 pence error on a Â£10,000
invoice. I told the boss that I was happy to pay them the 2 pence every time
it happenned if only I could stop leafing through that 100-page COBOL
monstrosity%footnote(The program is engraved on my soul -- it was called
SOP-1, for Sales Order Processing, and it had grown and grown far beyond the
ability of a neophyte like myself to ever understand. Trial and error was my
only weapon, and it was a definite trial with lots of errors.), but he didn't
think that was a great customer relations strategy.

The company was starting to move into Unix-based delivery platforms (System V
was the new thing back then; and a whole business would run on a tiny
mini-computer!). I was lucky enough to get my hands dirty with the new
technology, and learnt an awful lot in short space of time. It is a testament
to the power and success of the Unix paradigm that I'm still using many of
these skills today -- C programming, shell scripting, systems administration
and the like.

One of my tasks at the time was to package and distribute versions of our
systems to customer machines. I used a program called UUCP (Unix-to-Unix copy)
over dial-up modem links to push new updates onto machines out on site (and,
cheekily, used to get the customer machine to phone us back so that the
lengthy upload process would happen on their phone bill, not ours!). Things
are a little simpler now: someone invented a thing called the
Internet...%footnote(The Internet, of course, mostly runs on Unix-based
operating systems, as does your Pi, Android phones, and Apple computers.)

The job of packaging and distribution continues to be important, though, and
below I'll describe the mechanisms used for the Raspberry Pi's _Raspbian_
operating system.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 The Problem

Software packaging and distribution has to deal with versions, dependencies
and access:

- Different _versions_ of programs can incorporate lots of changes, including
  critical security fixes that need applying in a hurry. Especially on older
  systems and in low-bandwidth locations, minimising the amount of new
  download for a changed version is important.
- _Dependencies_ between programs are often tied to particular versions -- if
  a function that one program relies on changes, its package data must reflect
  its need for the old version.
- _Access_ to packages is relatively easy now -- most software is distributed
  as a network download. But what happens if the connection drops half-way
  through? Or if a million people all want updates on the same day?

These issues have been addressed in various ways; one of the most succesful
and wide-reaching is the Debian package management system, and this is the one
that we'll describe here.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 The Platform: GNU, Linux, Debian, Raspbian and Ubuntu

%(http://www.debian.org/, Debian) is a _distribution_ of %(http://www.gnu.org/,
GNU) %(http://www.linuxfoundation.org/, Linux), which is a Unix-like
operating system (like Android, MacOS, Ubuntu, Red Hat and many others).

%image(images/debian-logo-500x242.jpg, Debian, 500, 242)

For the Pi there's a special version of Debian called
%(http://www.raspbian.org/, Raspbian).

%image(images/raspbian-logo-400x234.jpg, Raspbian, 400, 234)

Probably the most popular version of Linux at present is
%(http://www.ubuntu.com/, Ubuntu), but because of an incompatibility between
the Pi's version of its %(http://en.wikipedia.org/wiki/ARM_architecture, ARM
microprocessor) and the Ubuntu build system, we can't use Ubuntu's
infrastructure on the Pi, except for programs which are _architecture
independent_ -- a term which we'll explain below when we show how to use
Ubuntu Personal Package Archives for Pi software distribution.


%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% %2 GNU and Linux
%%% 
%%% TODO
%%% 
%%% 
%%% %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% %2 Old and New: Debian and Raspbian
%%% 
%%% TODO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Ubuntu's Personal Package Archives

Broadly speaking, computer programming languages come in two sorts: _compiled_
or _interpreted_. Compiled languages are translated into machine code (binary
instruction sequences) before they can be run. Interpreted languages can be
run directly without any translation. This means that programs written in
interpreted languages are often _architecture independent_ -- they can run
without change on many different types of computer chips. Several languages
popular on the Pi fall into this category, including Shell Script and (with
some restrictions) Python.

%image(images/ubuntu-logo-400x283.png, Ubuntu, 400, 283)

As we noted earlier, Ubuntu Linux is very popular (and is also derived from
Debian). Ubuntu has a great set of infrastructure tools associated with it,
including _Personal Package Archives_ (PPAs) which simplify the task of
building, packaging and distributing software for all the platforms supported
by Ubuntu. If we're packaging an architecture-independent program, then, a PPA
can be a good way to distribute it. (Several Pi GATE programs are
%(download.html, distributed like this).)

Linux is %(http://www.fsf.org/about/what-is-free-software, open source free
software), and to make sure everyone gets access to the source of programs in
PPAs, Ubuntu only accepts Debian _source packages_ as uploads to the archives.
This means we have to build both a _source_ (^.dsc^) and a _binary_ (^.deb^)
package for each program; the next section describes how we do this.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Debian Packaging

A lot has been written about packaging, and its fair to say that it isn't the
easiest thing to get started with.%footnote(There are several reasons why
packaging is hard. Debian is a distribution of code largely produced by other
projects, so the packaging documentation often assumes that we're starting
from someone else's systems, whereas in our case that's not true. Its design
also dates back to a time where disk space and network bandwidth were very
limited and it was important to split systems down into very small chunks
stored on different disk partitions, problems that are less acute today.
Nevertheless the original designers did such a good job that it's still the
best there is. Kudos.) We'll take a quick-and-dirty approach here, and give
enough detail for a couple of simple cases:

- scripts and other architecture-independent packages (including _daemons_,
  which are scripts run at system startup)
- binaries from compiled languages like C (including shared libraries)

In each case the key to the process is to

- set up a ^Makefile^ in the top-level directory of your software tree which
  follows certain conventions for installation targets
- create a ^debian^ directory in the same place, containing data to control
  the package construction process

The rest of this section describes these steps; in %(#case-studies, the next
section) we'll give example code.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Creating the ^debian^ directory

The latter tree can be seeded using the ^dh\_make^ program like this:

%code(lang=bash)<
   sudo apt-get install devscripts debhelper
   dh_make -p=package-name\_1.0 --native
%>

This creates a set of files in the ^debian^ directory, many of which are
examples or boilerplate which can be ignored. The ones of the set that need
editing in our cases are:

- ^control^: contains the basic details of the package, its version and
  dependencies
- ^changelog^: describes the changes present in each version
- ^copyright^: describes the licence -- this should be
  %(http://www.gnu.org/licenses/, an open source licence)
- ^docs^: lists documentation files, e.g. a ^man^ page or a ^README^ for the
  software itself
- ^README^: describes details of the _packaging_ of the software, _not_ the
  software itself

There is also a file called ^rules^ which follows Makefile syntax and which
can be used to modify the details of the packaging process. In recent
configurations this file uses a lot of implicit rules and doesn't need any
changes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Conventions for the ^Makefile^

Having created our ^debian^ file tree we then need to create or adapt a
top-level ^Makefile^ so that it:

- has a default target (e.g. ^all^) which does any necessary compilation and
  linking of the software (for scripts this target probably does nothing)
- has an ^install^ target which adapts to the setting of a ^DESTDIR^
  (_destination directory_) environment variable

It is also convenient to wrap up the commands relating to packaging in
Makefile targets; the next section describes these commands.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Creating ^.deb^ and ^.dsc^ files

As noted earlier, the outputs from the packaging process are files of two
types:

- ^.deb^ files contain binary builds of a program, which is all ready to
  install on a running instance of Raspbian
- ^.dsc^ files contain the source code of a program, ready to be built


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#case-studies
%1 Case Studies

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 SimBaMon and BlinkIP

%(images/mopi/prototype-regulator-05.jpg,
%image(images/mopi/thumbs/prototype-regulator-05.jpg, mopi prototype 5,
200, 194))


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 WiringPi

%(images/wiring-pi-bbd.jpg, %image(images/wiring-pi-bbd-500x295.jpg, A
WiringPi breadboard layout, 500, 295))

