PiBrush -- Painting with the Pi and XLoBorg

_Turning an accelerometer into a paint brush with Raspberry Pi_
%meta(summary=Turning an accelerometer into a paint brush with Raspberry Pi)

_%(about.html#fred, Fred Sonnenwald), September 2013_

-----------------------------------------------------------------------------
%%% TODO
%1* DRAFT, unfinished
-----------------------------------------------------------------------------

%contents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#introduction
%1 Introduction

Two weeks ago we participated in the %(http://www.sheffield.ac.uk/ideasbazaar,
Ideas Bazaar) promoting
_%(http://pi.gate.ac.uk/posts/2013/09/16/open-culture-tech/, Open Culture
Tech)_, which I've translated to myself as a promoting how we can take finer
control of technology for ourselves using low-cost and open technologies. "The
proof is in the pudding" though, and actually demonstrating the point is a
much more powerful argument. To this end we prepared our exhibit to show off
various gizmos and widgets, including those based around Raspberry Pis. My
contribution has been the PiBrush.

%image(images/pi-brush-snap.jpg, Pi Brush snapshot)

The PiBrush is an interactive art and technology exhibit (a very grand name
for something so small) that simulates flicking paint off the end of a
paintbrush onto canvas, e.g. %(http://en.wikipedia.org/wiki/Jackson_Pollock,
Jackson Pollock). It utilizes two Raspberry Pis (one Model B and oneModel A),
a PiBorg %(http://piborg.org/xloborg/, XLoBorg) accelerometer, a battery pack,
a display, and two Wi-Fi dongles. The Model A is held by the user and waved
around. It collects acceleration data with the XLoBorg, which it then
transmits via ad hoc Wi-Fi to the Model B, which proceeses the data collected
into paint droplets and displays them on the screen, connected via HDMI.

%image(images/pibrush/pibrush_architecture.png, Pi Brush snapshot)

%[
| %(images/pibrush/modelb.jpg, %image(images/pibrush/thumbs/modelb.jpg, Model B, 200, 150)) | %(images/pibrush/modela.jpg, %image(images/pibrush/thumbs/modela.jpg, Model A, 200, 150)) |
%]

Since the Bazaar, we've also added a physical reset button to save the current
canvas and reset it to white.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#programming
%1 Programming

The hardware for this project is fairly straight forward. The XLoBorg plugs
directly into the GPIO pins as a block, and a GPIO button is just a button
connected between the ground and a GPIO pin - we've used BCM pin 17 or board
pin 11. The software is where the challenge lies.

I developed the code from scratch, and doing so required a variety of
knowledge. While I'd rate it as intermediate to advanced code to write, I'm
hoping to shed enough light on it here that it is only beginner to intermediate
to understand. The only real requirements are some basic familiarity with the
Python programming language, networking (IP addresses), and basic Physics. 

First, what code. The code is available on
%(https://github.com/hamishcunningham/pi-tronics/tree/master/pibrush/bin,
GitHub). This will always be the latest version. There's the python file
*accel\_client.py* which runs on the Model A and there's *accel\_server.py*
which runs on the Model B. The former reads in off the sensor and sends it
across the network, the latter recieves the data, does processing, and displays
the output on the screen.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#accel_client
%2 accel\_client.py

The client script is fairly straight forward. There are two unique points to
consider though. Reading in the accelerometer data and the networking code.
First though, we import the necessary libraries.

%code(lang=python,numbering=on,firstnumber=1)<
import socket
import XLoBorg
import time
import os
%>

*socket* is for networking and *XLoBorg*, the accelerometer. *time* is used to
for its sleep function and *os* to read in the server's IP address. So let us
first setup for the networking.

%code(lang=python,numbering=on,firstnumber=6)<
# network stufff
server = os.getenv('SERVER', 'modelb')
port = 5005
%>

Lines 7 and 8 define the IP address (or hostname) and destination port of the
server. You'll notice %(http://docs.python.org/2/library/os.html#os.getenv,
*os.getenv*) is used. This checks for what are called
%(http://tldp.org/LDP/Bash-Beginners-Guide/html/sect_03_02.html, environment
variables). They're set before the program is run. If there's nothing found
it defaults back to 'modelb' in this case though. I've arbitrarily picked out
the port number. Generally any number over 1024 is fine though.

The XLoBorg has its own specific initialization function to be run at the start
of a program using it. This uses the library to start communicating with the
accelerometer over the %(http://en.wikipedia.org/wiki/I%C2%B2C, I2C bus).

%code(lang=python,numbering=on,firstnumber=10)<
# setup for the accelerometer
XLoBorg.printFunction = XLoBorg.NoPrint
XLoBorg.Init()
%>

Next, the outgoing _socket_ is created. Sockets are the mystical term used to
describe the connector that programs use for talking to each other over the
internet. They come in different forms, we're using a UDP socket, also known
as a %(http://en.wikipedia.org/wiki/User_Datagram_Protocol, Datagram) socket.
The special ability of these that we're taking advantage of here is that
UDP is simple and stateless. It's easy to setup and the Model A can continually
send and it doesn't matter what the Model B does. That makes for conveniently
robust communication in this scenario.

%code(lang=python,numbering=on,firstnumber=14)<
# make the socket connection
sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
%>

Afterwards, the main program begins as we enter an infinite loop -- we want
to continually read the accelerometer and send that information off. Line 17/18
are used to construct the outgoing message. It conists of three comma
seperated, signed, floating point values which are fed from the special XLoBorg
*ReadAccelerometer* function. (See
%(http://docs.python.org/2/library/stdtypes.html#string-formatting, String
Formatting Operations) for details on this.) *sock.sendto* then sends the
message and then %(http://docs.python.org/2/library/time.html#time.sleep,
*time.sleep*) causing Python to wait for a small interval. Then it all starts
again -- about 200 times a second.

%code(lang=python,numbering=on,firstnumber=16)<
while True:
    message = '%+01.4f,%+01.4f,%+01.4f' \
            % XLoBorg.ReadAccelerometer()
    sock.sendto(message, (server, port))
    time.sleep(0.005)
%>

That's it. Not so bad. A nice warm up...


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#accel_server
%2 accel\_server.py

The server script is where the real meat of the programming is as it handles
the simulation and display. Similar to accel\_client.py, necessary libraries
are first imported.

%code(lang=python,numbering=on,firstnumber=1)<
import socket
import select
import pygame
import time
import numpy
import math
import datetime
import random
import os
import RPi.GPIO as GPIO
%>

*socket* we've already met, but *select* is new, and related. It's used to
avoid what's called blocking, which is when the program is forced to wait for
new data. Using select, the network code becomes non-blocking, which allows the
program to function even if the client isn't transmitting any data.
%(http://www.pygame.org/, *pygame*) is a the library used for drawing on the
screen. *numpy* is used for fast array operations to help speed up program
execution -- the RaspberryPi isn't the world's fastest computer and every
little helps.

*math* contains the functions like _sin_ and _cos_ which we use to handle some
of the translation from where the accelerometer is to where the paint is on the
screen. *datetime* is a bit of code that got accidentally left in from an old
version -- oops! (It was used to print the current date on the screen during
debugging to tell if the program was frozen or not.) *random* is used to
generate, as it sounds, random numbers. Finally *RPi.GPIO* is used to talk with
the GPIO pins.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#initialization
%3 Initialization

%code(lang=python,numbering=on,firstnumber=13)<
# ==============
# initialization
# ==============
%>

Next comes a lot of boring and tedious bits of code which I've classed under
initialization. These are various pieces of code that need to be run just once
to get things started.

%code(lang=python,numbering=on,firstnumber=17)<
# port to listen on
port = 5005

# setup networking
sock = socket.socket(socket.AF_INET,
        socket.SOCK_DGRAM) # UDP
sock.bind(("0.0.0.0", port))
sock.setblocking(0)
%>

First there's the network code. This will look familiar. It's the flip side of
what was done on the client. We define the network port to listen on and then
create a socket. Then we tell the socket to listen using the *.bind()*
function. 0.0.0.0 in this case tells it to listen on all network interfaces
(so you could use Ethernet or Wi-Fi). Then *.setblocking()* is needed for that
non-blocking thing I mentioned before.

%code(lang=python,numbering=on,firstnumber=26)<
# directory for saves
SAVEDIR = os.getenv('SAVEDIR', '.')
%>

*os.getenv* is used again, the first of several times. This time it's used to
set a directory to store save files in, and otherwise defaults to '.', which is
the current working directory (the folder you were in when you started the
program).

%code(lang=python,numbering=on,firstnumber=29)<
# setup GPIO input for reset
GPIO.setmode(GPIO.BCM)
GPIO.setup(17, GPIO.IN, pull_up_down=GPIO.PUD_UP)

# variable to store button state
button = 0
%>

The above code initializes the GPIO for input. *.setmode()* says we'll be
using the
%(http://elinux.org/RPi_Low-level_peripherals#General_Purpose_Input.2FOutput_.28GPIO.29,
Broadcom pin names). *.setup* then says we're looking for input on pin 17. It
also specifically tells the chip to use the internal resistor on the pin so
that there's no floating.
(%(http://www.cl.cam.ac.uk/projects/raspberrypi/tutorials/robot/buttons_and_switches/,
Here) is a pretty good article to which explains floating, some interesting
extra reading.) The last thing is the *button* variable which is used to
indicate whether or not the button hooked up to the GPIO has been pushed or
not. By default it's not been so it starts at 0.

%code(lang=python,numbering=on,firstnumber=36)<
# screen solution
XRES = int(os.getenv('XRES', 1920))
YRES = int(os.getenv('YRES', 1080))

# setup display
pygame.init()
screen = pygame.display.set_mode((XRES, YRES))
# reset to white
screen.fill((255, 255, 255))
# push white
pygame.display.flip()
%>

Then comes screen initialization. First we read in the X resolution and Y
resolution. Then we initialize pygame (line 41) and set the display mode with
our resolution (line 42). By default the screen is black, but I think a nice
white canvas is preferable so we *.fill()* the screen with white. _(255, 255,
255)_ is 0-255 (red, green, blue). All colors combined = white (think prisms).
By default pygame writes to a buffer section of memory, so *.flip()* is
required to tell it to display the current buffer. (A second buffer is then
availble to draw on until the next flip -- this is called double buffering.)

%code(lang=python,numbering=on,firstnumber=48)<
# length of moving average array
AL = 20

# accelerometer storage for moving average
AXa = numpy.zeros((AL, 1))
AYa = numpy.zeros((AL, 1))
AZa = numpy.ones((AL, 1))

# array index for accelerometer data
Ai = 0
%>

Next we create the variables used for storing the raw accelerometer data --
that's the *AXa*, *AYa*, and *AZa* variables. There's a *numpy* array for each
direction, X, Y, and Z. X is into the screen, Z down it and Y across. But why
arrays? Surely a single reading should be in a single variable? Normally that
would be the case, but we're going to use something called a _moving average_
(MA) to filter the input data.

An MA is the average of, in this case, the last 20 readings. Some sort of
filtering is almost always necessary when dealing with the sort of analog input
data that comes from an acceleromter to prevent sudden jumps in the readings
(e.g. you knocked it) from having an undue impact on the processing. An MA is a
convenient and easy way to do it. We simply input The current reading at index
*Ai* and then increment Ai until it exceeds *AL*, then wrap it back around.
You'll see this in the code later. I use *numpy* here because they execute very
quickly (read: effeciently) and there are handy functions to make things
simpler. Like *.ones()* to initialze all of *AZa* to a value of one -- there's
always by default 1G of gravity downwards.

After dealing with the accelerometer directly are declarations for those
variables dealing with gravity. *GX*, etc., store the best (most recent) guess
of what direction gravity is in, as once we start moving we have a combined
acceleration of gravity plus the user's movement. We need this to subtract
gravity back out so we know how the user is moving. Ideally this would be done
with a gyroscope, but we don't have one of those so we make do.

%code(lang=python,numbering=on,firstnumber=48)<
# store gravity when fast is detected..
GX = 0
GY = 0
GZ = 1

# polar gravity
PGR = 0
PGA = -math.pi/2
PGB = 0

# screen gravity
PSGR = 1
PSGA = -math.pi/2
PSGB = 0

# accelerometer values
AX = 0
AY = 0
AZ = 0

# rotated for screen accelerometer values
GAX = 0
GAY = 0
GAZ = 0
%>

*PGR*, etc., store the equivalent
%(http://en.wikipedia.org/wiki/Polar_coordinate_system, _polar coordinates_)
of the gravity estimate, where R is the radius to the point from the origin,
and A and B are the angular rotation about the Z and Y axis. The polar
coordinates are used for the actual subtraction as subtracting the gravity
vector from the current acceleration vector is very easy like this -- it's an
extension of the regular
%(http://hotmath.com/hotmath_help/topics/adding-and-subtracting-vectors.html,
subtraction of vectors).

*PSGR* are the polar coordinates of gravity in the screen, which is an
accleration field that's always downwards. If you consider that the Model A
might not be parallel to the screen while being waved about (e.g. it's held
rotated) then we need to rotate the acceleration field it experiences back to
screen normal. I'm actually not entirely sure about this -- this was all new
to me when I was writing it, so this is just a guess really. It seems to work
though so I've left it in. In my experience most projects like this have fiddly
bits like this.

*AX* etc. store the result of the moving average of the acceleromter data.
*GAX* etc. store the current acceleration as from *AX* but rotated correctly
for the screen.

%code(lang=python,numbering=on,firstnumber=83)<
last_G = 0

# timing information
last_time = time.time();
%>

*last\_G* stores the time at which the last estimate of the direction of
gravity was taken. *last\_time* stores the time at which the last loop was
executed. This is used for estimating distance the brush has travelled as
part of a process called _twice integration_. You think someone would have
written up a nice simple explanation of this, but nothing turns up after a
quick Google.
%(http://www.ugrad.math.ubc.ca/coursedoc/math103/site2012/keshet.notes/Chapter4.pdf,
This) is a somewhat high level explanation of what's going on, and
%(http://www.astarmathsandphysics.com/a_level_maths_notes/M1/a_level_maths_notes_m1_acceleration_velocity_and_displacement.html,
this) is a bit simpler, but I'm not terribly happy with either explanation.
I'll try and simplify it a bit, or at least put it a bit more concisely.

Imagine you're in a car traveling down the motorway at 100 kph. In one hour
you will have travelled 100 km. Easy? That's simple integration, going from
velocity to displacement. Acceleration though, is the rate of change in
velocity, e.g. the speed at which the needle of the speedometer in the car
climbs. So now imagine accelerating at 1 kph per second, after 10 seconds
you'll be going 10 kph faster, so instead of 100 kph you're now going 110 kph.
Apply that to the distance you've travelled and you have twice integration.
(Fun fact: if you kept up that acceleration, after an hour you'd be going 3,700
kph and would have traveled 36,370 km. Or almost around the Earth.)

%code(lang=python,numbering=on,firstnumber=88)<
# brush info
BX = 0 # position
BY = 0
VX = 0 # velocity
VY = 0
P = 0 # amount of paint on brush
S = 0 # distance brush has traveled
last_stroke = 0
%>

This next bit of code initializes the variables regarding our virtual
paintbrush. *BX* and *BY* for the position on the screen - no Z because it's
only going up and down. *VX* etc. for it's velocity, or speed. *P* to keep
track of how much virtual paint is left on the brush, and *S* to keep track of
how far the brush has travelled - this is used in determining how far apart the
paint splatters ought to be. *last\_stroke* is the time at which we last
painted.

%code(lang=python,numbering=on,firstnumber=97)<
# seed random number generator
random.seed(time.time())
%>

This last bit of code initializes the random number generator with the current
time. Without this, it would be possible to get the same random numbers over
and over each time the program was run. We use the random numbers for picking
out the paint color each stroke.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#functions
%3 Functions

More to be written.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#systemsetup
%1 System Setup & Running

The other nigly details to get things going. To be written.
