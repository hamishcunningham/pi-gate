MoPi: Hot-Swap Mobile Power for the Pi

%/* _
%(about.html#hamish, Hamish Cunningham),
%(about.html#lubo, Lubo Bontchev),
and %(about.html#fred, Fred Sonnenwald),
%br August 2013 -- June 2014_ %*/

%1* MoPi is mobile, hot-swap and 24/7 power for the Raspberry Pi. %br
%(/pages/get-mopi.html, I want one! \(how to order\))

_(In early 2014 we ran a %(http://tinyurl.com/mobile-pi, Kickstarter campaign)
to fund the first production version, which is due for delivery in June 2014.
If you missed it, you can %(/pages/get-mopi.html, join our pre-order waiting
list here).)_%footnote(_A huge thank you to Bo Meson, Fred Sonnenwald, Gen
Gorrell, Vladimir Marinov, Georgi Marinov, Louise Illien, Julian Briggs,
Caroline Ivimey-Parr, Angus Roberts, Joe Polifroni, Todor Primov, and all our
%(https://www.kickstarter.com/projects/hamishcunningham/mopi-mobile-and-24-7-power-for-the-raspberry-pi/backers,
Kickstarter backers)!_)

%meta(summary=Hot-Swap\, Mobile and 24/7 Power for the Pi)

%contents


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Pi to Go!

MoPi is mobile and 24/7 power for the Pi. On your bike, up a tree, or for your
home server: we've got you covered.

%(images/mopi/logo-heli-1.png,
%image(images/mopi/logo-heli-1-200x150.png, MoPi Heli Logo, 200, 150))

Features:

- multiple inputs -- standard batteries, car power sockets, old laptop
  supplies, solar panels, ... (attached via screw terminals)
- hot-swap power replacement without stopping work
- shutdown the Pi cleanly when batteries discharge
- integrated on/off switch
- UPS (uninterruptible power) mode when using both batteries and mains
- on-board LED indicators and on-Pi notifications
- configuration of multiple battery chemistries and numbers of cell from a UI
  on the Pi
- full API in Python, plus a shell-friendly command-line interface
- stackable headers allowing connections of multiple boards at once (e.g. MoPi
  + XLoBorg, or MoPi + AirPi, or etc.).
- PCB remoting pads for the power switch
- self-resetting fuse for over-current protection
- two-way communication via the I2C bus
- remote power-off: tell MoPi to power down the Pi when logged-in remotely
  (after a clean shutdown, of course)
- timer-based wake-up: tell MoPi what time you want your Pi to wakeup, then
  power it down and MoPi will boot the Pi as requested
- 3.3V supply mod: swap three resistors and supply 3.3V, overpowering the Pi's
  on-board regulator and saving the power that is dissipated there, for weight
  and battery life critical applications like ballooning
- wide input voltage range: 6.2V to 20V%footnote(We quote a 20V max voltage to
  leave some headroom. We've run the board up to 25V but don't recommend it as
  a general rule.)

And it even fits in the Pibow (and other well-known Pi cases):

%(images/mopi/mopi-in-pibow.jpg,
%image(images/mopi/mopi-in-pibow-500x375.jpg, MoPi in a Pibow, 500, 375))


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#userguide
%1 User Guide

%#warnings
%2 Warnings!!!

- DO NOT plug MoPi onto your Pi while the Pi is powered up!
- DO NOT touch electronic components when they're powered up -- you may
  damage them, or burn your fingers!
- AVOID handling circuit boards when charged with static!
- DO NOT feed MoPi to your dog, eat nuts if you're allergic to them, or lose
  your sense of humour.%footnote(A lawyer questioning a doctor during a trial:
  %br
Q: "Doctor, before you performed the autopsy, did you check for a pulse?" %br
A: "No." %br
Q: "Did you check for blood pressure?" %br
A: "No." %br
Q: "Did you check for breathing?" %br
A: "No." %br
Q: "So, then, it is possible that the patient was alive when you began the
autopsy?" %br
A: "No." %br
Q: "How can you be so sure, doctor?" %br
A: "Because his brain was sitting on my desk in a jar." %br
Q: "But could the patient have still been alive nevertheless?" %br
A: "It is possible that he could have been alive and practicing law
somewhere.")


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Quick Start

%(images/mopi/quickstart/schematic6.png,
%image(images/mopi/quickstart/schematic6-500x745.png, Quick start guide, 500,
745))


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#quick-install
%2 Installation

If you're in a hurry see the graphic above, and:

# Install the battery monitoring software:
  - sudo apt-get update
  - sudo apt-get install simbamond
# Connect the batteries
# Connect the Pi and hit "on"

For more details on each step, see below.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%3 Installing the Software

As noted above, you can install the battery monitoring software like this:

  - sudo apt-get update
  - sudo apt-get install simbamond

(We assume you're using the %(http://www.raspbian.org/, Raspbian flavour) of
%(http://debian.org, Debian) GNU Linux here.)

Occasionally this method may cause glitches (if you've a very old version of
the rest of the operating system installed, for example). The most cautious
recipe is to update your firmware and the operating system, then install the
MoPi software, and to reboot between each step:

- sudo apt-get update
- sudo apt-get dist-upgrade
- sudo reboot
- sudo rpi-update
- sudo reboot
- sudo apt-get install simbamond
- sudo reboot


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%3 Connecting the Power and the Pi

Next connect one or more power supply to MoPi using the screw terminals on the
underside of the board. Then gently push fit MoPi onto your Raspberry Pi's
GPIO pins.

The components on the MoPi are as follows:

%(images/mopi/mopi-with-key-schematic.png,
%image(images/mopi/mopi-with-key-schematic-500x262.png, Board connections schematic 1,
500, 262))

When connecting two power sources (e.g. two battery packs, or one solar panel
and one battery pack) the ground wires (-ve, typically black) both share the
middle connector on the screw terminals. The live wires (+ve, typically red)
then get one each of the other connectors. The lower of the supply connections
shown in the schematics corresponds to _source 1_; the other to _source 2_.

When you've connected your supplies, MoPi then fits onto the Pi as shown on
the right:

%(images/mopi/mopi-with-key-schematic-02.png,
%image(images/mopi/mopi-with-key-schematic-02-500x138.png, Board connections schematic
2, 500, 138))

The charge level of each source is signalled by the two amber LEDs on the top
of the board, and the overall health of the supplies by a single
RGB%footnote(RGB: red, green and blue.) LED.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%3 Turn On, Turn Off

When the Pi is powered off, press the power button for 2 seconds to turn it
on.

When the Pi is powered on, press the power button for 3 seconds to turn it
off. This will shut the Pi down cleanly (which can take up to around 30
seconds). If you hold the power button down for 10 seconds, the power will
shut down immediately.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Troubleshooting and FAQ

%(images/mopi/packet/img-20140421-113013.jpg,
%image(images/mopi/packet/img-20140421-113013-500x391.jpg, Packaging 4, 500,
391))

-----------------------------------------------------------------------------
*>>> Should I get a stackable header or a low-profile one?* %br
*>>> What if the power switch isn't accessible?*

If you want to fit your MoPi into tight spaces, you probably want a small
(low-profile) header. If you want to stack MoPi with other Pi add-on boards,
then you want a big, "stackable", header.

Note that if you do get the stackable version, when you put another board on
top of MoPi it may hide the power switch and/or the LEDs. In the case of the
power switch there are solder pads on the PCB to allow fitting of a remote
switch.


-----------------------------------------------------------------------------
*>>> What type of regulator chip is it? What is the voltage range?*

MoPi uses a switched-mode regulator (a TPS5430), so almost no power is wasted.

The input voltage range is 6.2V to 20V. (There's no step-up circuitry so the
battery or solar panel rig or etc. has to supply 6.2V at minimum.)


-----------------------------------------------------------------------------
*>>> Is it safe to bypass the Pi's built-in fuse?*

Yes -- in this case...

The issue: MoPi supplies power to the Pi over the GPIO pins, instead of via
the micro USB connector (which it leaves free so that mains power can be
plugged in at the same time as batteries if required). The 5V feed from GPIO
involves bypassing the Pi's built-in fuse (which is in line with the USB
connector).

Is this safe?

Given a correctly functioning Pi and peripherals, then the answer is a clear
"yes". But what about if the Pi is faulty, or if a pin is shorted out, or if
someone connects a 3 bar electric heater to it? :-)

Three considerations:

First, MoPi is currently capable of supplying up to 2A, after which there is
an internal current limiting circuit. It uses standard voltage and power
regulation circuitry which is robust and mature, and will not allow over-volt
or over-current on the output.

Second, we're supplying from batteries, not mains -- so as long as we don't
over-consume from the battery (which in principle we can't short of a major
internal fault) there's a limit to the amount of power we can supply to a
faulty Pi.

Third, not having an internal fuse is pretty standard behaviour -- poke around
in the electronics of all those power supplies sitting around in your desk
drawer and you won't generally find fuses.

Having said that, we added an autorecovery fuse to version 3 just to be
ticking all the boxes :-)


-----------------------------------------------------------------------------
*>>> Can I access the voltage data on MoPi from the Pi?*

Yes!

The software on the Pi that talks to MoPi is open source and available here:
https://github.com/hamishcunningham/pi-tronics/tree/master/simbamon (See also
http://pi.gate.ac.uk/pages/download.html .)

It listens to MoPi and logs the data in a standard manner, which other
applications can then consume as required. There's also a Python API and a
command-line interface (CLI).

The Raspbian maintainers have added this software to their repository, so you
can install it in the same way as any other Pi sofware.


-----------------------------------------------------------------------------
*>>> Can I combine mains and solar power?*

Yes!

This should work so long as you connect the mains-derived power to one of
MoPi's inputs (it will have to be a supply >= 6.2 volts). MoPi will then use
mains whenever the solar output dips below the mains supply. The ideal would
be a solar panel rig that outputs e.g. 15v coupled with a 12v mains supply, or
some similar config.

(We're running a rig now in the workshop that has two 18V panels in parallel;
watch http://pi.gate.ac.uk/ and we'll post the results!) 
TODO


-----------------------------------------------------------------------------
*>>> How do we avoid deep discharge of rechargeables?*

Rechargeable batteries don't like being completely discharged. We always need
to stop drawing from the battery at some distance above the minimum voltage
level. This distance varies for different battery chemistries (NiMH, LiPo,
lead/acid, etc.) and for different multiples (eight AAs vs. two PP3s vs. one
car battery, etc.).

MoPi listens continuously to the voltage level on the battery inputs. How does
it know when that level is getting low? Let's identify two separate low-level
points: first, the absolute low voltage level is the point where our
micro-controller can no longer reliably run the switching regulator to produce
a constant 5V (around 6.2 volts). The second low voltage point depends on the
particular battery configuration (for eight NiMH 1.2 volt cells it is around 8
volts). For non-rechargeables, or solar panels or a water turbine, it is the
same as the absolute low level (6.2V).

MoPi is responsible for deciding the input voltage is low (for either or both
of its two supplies), and then warning the user and/or shutting the Pi down
cleanly (from software first, using "sudo halt", and then by cutting power).
How do we decide when to do this?

First we have a default configuration, which is the one which we will be
supplying in the "battery heaven", UPS and outdoor kit rewards: eight
high-capacity NiMH AA cells. In the absence of any other data, we assume that
this is what is connected, and when the output voltage descends to around 8.5
volts we turn the main indicator LED red and send warnings to any user logged
into the Pi. (There are various other levels defined that choose blue -- the
highest level indicator -- vs. green, and so on, and separate LED indicators
for low level on the two supply inputs.)

Of course this default configuration won't work for all cases, so then we
allow choice of another set of options from the Pi itself. (Currently we're
looking at a set of 16 different options, but that may change in the next few
weeks as we finalise the third prototype.)


-----------------------------------------------------------------------------
*>>> This, that, an' t'other*

- Sometimes the reported voltage for a particular source seems to be high
  enough to drive the Pi, but MoPi considers it too low -- why? When a new
  source is connected it is shunted through a simulated load for a few tenths
  of a second. Batteries drop their voltage under load, and the lower their
  level of charge, the larger the drop. MoPi measures the voltage under load,
  and if it is too low it will refuse to use that supply.
- If you get a message like "libkmod: ERROR ../libkmod/libkmod.c:554
  kmod_search_moddep: could not open moddep file
  '/lib/modules/3.6.11+/modules.dep.bin'" when installing try a reboot
  followed by "sudo apt-get -f install".
- If the I2C bus appears not to be working after installing SimBaMon, try a
  reboot (as sometimes the Python SMBus module appears not to load as
  predicted).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Background: Mobile Pi Power

The Pi has many advantages as a mobile platform: if the rain gets in, or a dog
eats it, a replacement doesn't break the bank, and, for a general-purpose
device, power requirements are very low.

Early in 2013 we realised that we needed better power management for our
mobile projects on %(http://pi.gate.ac.uk/, Pi.GATE.ac.uk). Five volt USB
battery packs are common, but none of them can communicate their level of
charge to the Pi. That means lots of unanticipated power cuts -- a good way to
corrupt your SD card :-(

And then we realised that standard rechargeables are more planet friendly. And
then that it would be cool to be able to hot-swap supplies, and that if we
could do that then why not make it a UPS too, and how about adding a power
switch, and...

Fast forward: we ran a successful
%(https://www.kickstarter.com/projects/hamishcunningham/mopi-mobile-and-24-7-power-for-the-raspberry-pi/,
Kickstarter crowdfunding campaign) and now we're delivering the 4th generation
of our mobile power board. Read on!

Below we'll run through the characteristics of mobile power for the Pi, and
follow through with the design of *_MoPi_*, an add-on battery pack circuit
with Raspbian-friendly software that does lots of useful stuff for the Mobile
Pi.

There are three dimensions to the problem of mobile power for the Pi:

- _regulation_, to supply the constant 5 volts%footnote(The keen amongst you
  may know that the Pi can, in fact, run on 3.3V -- more on that later.) at up
  to around 1 amp that the (Model B) Pi requires
- _control_:  keeping a check on battery charge, switching the regulator off
  when charge is getting low, and reporting the current level to a monitor
- _monitoring_: reading level indications from %(basics.html#gpio-pins, a GPIO
  connection), reporting it to the Pi user and shutting the operating system
  down cleanly when levels get critically low

The first two of these need some special hardware; the third is written as a
software _daemon_.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 The Prototypes

We've now developed four versions (the last of which is being supplied to our
Kickstarter backers in June 2014). Here's what version 4 looks like:

%(images/mopi/version-4-top.jpg,
%image(images/mopi/version-4-top-500x.jpg, Version 4 top, 500))

%(images/mopi/version-4-bottom.jpg,
%image(images/mopi/version-4-bottom-500x.jpg, Version 4 bottom, 500))

Here's what the level 3 revision looked like (_without_ the wiring connector
or the GPIO connector or the power switch, which were soldered by hand after
these pictures were taken):

Top of the board:
%image(images/mopi/pre-production-boards-02.jpg, Pre-production MoPi top, 500)

Underneath the board:
%image(images/mopi/pre-production-boards-01.jpg, Pre-production MoPi bottom,
500)

The stackable headers (for when MoPi is used in tandem with other add-on
boards) take up quite a lot of vertical space in order to provide a set of
pass-through pins above the MoPi board. Therefore we're offering two versions,
one with the stackable header and one with a standard low-profile header.

This is the stackable header that we're using (from Adafruit):
%(http://www.adafruit.com/products/1112,
%image(http://www.adafruit.com/images/medium/1112_MED.jpg, Adafruit Stacking
Header))

If you're opting for the low-profile header you can see an example here, on
the level 2 board:
%image(images/mopi/mopi-underside.jpg, MoPi 2 underside, 500).

This was the second-generation prototype board:

%image(images/mopi/proto2-01-500x379.jpg, mopi prototype 2/1, 500, 379)

The shape of the PCB allows it to fit into the
%(http://shop.pimoroni.com/collections/pibow, Pibow) without blocking the Pi's
display output (soon to be used for the
%(http://www.raspberrypi.org/, Pi Foundation)'s
%(http://raspi.tv/2014/raspberry-pi-official-7-inch-dsi-prototype-preview,
DSI touch screen)). There's space for a pass-through GPIO header so that other
add-on boards can share space on the Pi, separate LEDs for overall function
and for the two power inputs, and a neat little power switch on the top.

(The good people at %(http://www.pimoroni.com/, Pimoroni) are doing a custom
lid for their %(http://shop.pimoroni.com/collections/pibow, Pibow) case to
give direct access to MoPi's power switch.)

And here are the first-generation prototype boards (with separate regulator
and controller; click to zoom):

%[ | %\ %\ |
%(images/mopi/prototype-regulator-05.jpg,
%image(images/mopi/thumbs/prototype-regulator-05.jpg, mopi prototype 5, 200, 194))
| %\ %\ %\  |
%(images/mopi/prototype-controller-01.jpg,
%image(images/mopi/thumbs/prototype-controller-01.jpg, mopi prototype 6, 270, 195))
| %]

The software is %(http://www.fsf.org/about/what-is-free-software, open source)
(of course) and available at
%(https://github.com/hamishcunningham/pi-tronics/tree/master/simbamon, our
Pi-Tronics repository).

The basic functionality was all in place by early 2014; the success of the
Kickstarter allowed us to add lots of new features, including:

- dealing with more rechargeable battery chemistries
- the internal Pi circuitry can run on 3.3 volts (saving some power loss in
  the on-board linear regulator -- %(http://www.daveakerman.com/, Dave
  Akerman's balloons) use this strategy to increase battery life); MoPi can
  now be hacked to support 3.3 volt output :-)
- 2-way communication (on the I2C bus) between MoPi and Pi supports
  configuration from the Pi
- screw terminals, stackable headers, remoting pads and self-resetting fuse
- two-way communication and remote power-off
- timer-based wake-up added

The next two sections discusses the %(#perfect, overall design) of MoPi and
then the %(#monitoring, monitoring and configuration software). Then we give
some detail of %(#howitworks, how it works), and look at %(#measures, system
performance) and measure how long a Pi can run with various configurations and
battery types. We also descibe a few of the %(#wild, millions of applications)
for mobile Pi power. Finally we link to %(#batteries, sites selling batteries)
and some other %(#other, useful resources).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#perfect
%2 The Perfect Battery Pack

%(http://pi.gate.ac.uk/static/pages/images/mopi/perfect-pack.png,
%image(images/mopi/perfect-pack.png, The perfect pack, 563, 295))

What would the perfect Pi battery pack look like? It should be:

*Low cost*. Dedicated battery supplies like those sold as phone charging
devices are great, but when they no longer hold charge the whole unit has to
be recycled. Standard commodity batteries and the reusable chargers that serve
them are well-established and already present in many households. They're the
cheapest and most flexible option.

*Flexible*. Got a solar panel handy? I want to plug it into the circuitry and
have it drive the Pi as long as the sun shines, then let a battery take over
when the clouds come. Stuck for power but got an old laptop supply or 12 volt
car charger handy? Strip the cables, connect, and power my Pi please! Plugging
a bunch of peripherals? I want to be able to drive them all via my battery
pack. And etc.

*Polite*. When you're running your laptop on battery and it runs out of juice
it gives you a nice polite warning message or two, and, when the level gets
really low, it automagically shuts down the machine. This is important to
allow the operating system (e.g. %(basics.html#footnote1, Raspbian Linux) on
the Pi) to close up any open files and generally tidy the house before power
disappears. Just killing the power without warning is risky -- sometimes
nothing bad happens, but in the worst case you can end up with a machine that
won't boot and needs a complete reinstall. So I want my battery pack to signal
the Pi when levels are low, so that the Pi can shut itself down cleanly. Good
manners are important, after all :-)

And if the battery pack is going to tell the Pi when it is getting low and
needs to shut down, why not have an *on/off switch* into the bargain? The
"off" signal triggers clean shutdown, and is very convenient when you're using
the Pi in any kind of kiosk or appliance context. Several projects have
implemented this type of on/off facility in its own right -- e.g.
%(http://lowpowerlab.com/atxraspi/, the ATX Pi supply) or the
%(http://www.susa.net/wordpress/2012/11/raspberry-pi-power-controller/, PIC
controller) -- it's definitely a useful function to have on board.

*Uninterruptible*. I don't want to stop work when my battery is low if I've
got a charged pack handy (or a different source of power, like a car cigarette
lighter socket or the like). So I'd like my battery pack to support *hot-swap*
of a new electricity supply, either a new set of batteries or some other new
input.

*Eco-friendly*. One of the great things about the Pi is its low carbon
footprint. The recent ones in %(http://pi.gate.ac.uk/, my lab) are made in
Wales, so they haven't travelled half way around the world to reach me. The
base system is bare-bones, which encourages reuse of power supplies, monitors,
cables and the like. The power consumption is low -- particularly for the
Model A, which gets by on 300 mA or below (at 5 volts this adds up to around
1.5 watts -- contrast that with
%(https://secure.www.upenn.edu/computing/resources/category/hardware/article/computer-power-usage,
50 watts and above) for a desktop PC!). There's no spare planet; there's no
Plan B if we destroy this one. So we definitely want to support rechargeable
batteries, and preferably not the built-in variety that are hard to recycle.

*Communicative*. I want to know when the battery is full, when it is starting
to get low and when it is critical. I want to be able to get those signals
both when logged in to the Pi and visually from the battery pack itself.
(Look! Flashing lights!)

*Robust*. I'm pretty unreliable at the best of times. When crawling through
the underbrush with a camera-equiped Pi rig
%(/posts/2013/08/05/chasing-pine-martens/, in search of Pine Marten lairs) I'm
very likely to plug the wrong end of the stick and end up with my foot in my
mouth, to coin a mixed metaphor or three. Over-volt and spike protection are
definitely requirements.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 The MoPi Software Suite

This section describes how the MoPi software suite works and how the
architecture of MoPi hangs together.

There are four main parts of the puzzle:

- A _daemon_ which runs in the background on the Pi, which is called
  %(/pages/mopi.html#simbamon, SimBaMon) (a Simple Battery Monitor). SimBaMon
  is available as a package for Raspbian, and installing it pulls in all the
  other facilities.
- An interface that communicates with the MoPi hardware over the I2C protocol.
  This interface is wrapped up as a Python API.
- A command-line tool that uses the Python API and provides a language-neutral
  portable method for talking to the board from the Pi.
- A configuration user interface that simplifies the process of setting up
  MoPi to deal with different types and numbers of batteries, and other types
  of power supply.

All of the code for these components is
%(https://github.com/hamishcunningham/pi-tronics/tree/master/simbamon,
available on GitHub).

The rest of this section discusses each of the main elements in turn,
describes how to check up on the beast as it runs, and finishes up with more
detail of the implementation of the daemon.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 The SimBaMon Daemon

When the Pi (or any other Linux system) boots, several system services are
started that will run continuously until the machine is shut down again. These
services are called _daemons_, and this is how SimBaMon is implemented.
Following the standard naming convention, the daemon is called ^simbamond^,
and the first point of entry (used by the operating system to start, stop,
etc.) is a script that lives in
%(https://github.com/hamishcunningham/pi-tronics/blob/master/simbamon/simbamond.default,
^/etc/init.d/simbamond^). This script (which is a management type person)
calls another to do all the real work; this other (hard working type) lives in
%(https://github.com/hamishcunningham/pi-tronics/blob/master/simbamon/simbamon,
^/usr/sbin/simbamon^).

One of key features of MoPi is that it supports many different types of
batteries and many other types of power supply (from solar panels to elastic
bands!). Coping with the requirements of all these monsters needs a huge wodge
of configuration data, which (following Debian Linux convention) lives in
^/etc/default^ in a file (again, confusingly) called
%(https://github.com/hamishcunningham/pi-tronics/blob/master/simbamon/simbamond.init,
^simbamond^).%footnote(Again confusingly -- this will become a theme -- the
names of the files as they live in the source package are different from their
names when installed. If you don't like being confused, you might want to
avoid talking to computer people as a general rule. For example, the MoPi
board works on milivolts; the I2C communication uses centivolts; the user
interface uses volts; the API uses milivolts. And all for good reasons!)

Together these three script files make up a new system service that polls the
MoPi hardware every couple of seconds and shouts loudly when an electron
shortage appears on the horizon. If no one is listening and the shortage gets
acute, the daemon tells the Pi to take a rest and issues the ^shutdown^
command.

There is %(/pages/mopi.html#simbamon, more detail below).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 The Python API

How do we talk to the hardware? From MoPi version 3 onwards we shifted away
from using the Pi's general-purpose GPIO pins (using a tool called WiringPi).
This worked well, but it used a pin for each bit of data that we wanted to
ship between the board and the Pi. As time went on we found more and more data
that we needed to share (and we also came across other add-on boards that use
lots of GPIO pins -- e.g. %(http://pi.gate.ac.uk/posts/2014/02/07/airpi1/,
AirPi)).

Luckily the Pi also hosts several other inter-board communication options,
including the I2C protocol, which uses only two pins, can talk to multiple
devices over the same two wires, and allows transfer of much larger amounts of
data.

There are two ways to talk over I2C from the Pi: a set of command-line tools
written in C, and a Python module. Both work, but the Python version seems to
have had more attention from Pi users and developers, and has support for
multi-byte reads (which requires a bit of hacking to get working in the C). So
we've implemented an API for MoPi in Python%footnote(And no one complained
about the whitespace rules! Who'd have thought it?!), which now lives in a
file called
%(https://github.com/hamishcunningham/pi-tronics/blob/master/simbamon/mopiapi.py,
^mopiapi.py^).

For Python programmers this code provides a natural and efficient method of
including MoPi facilities in their programs.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 MoPi from the Command Line

The observant amongst you may have noticed that SimBaMon is not written in
Python%footnote(In common with most daemons, SimBaMon is written in shell
script.) -- how does the daemon talk to the board when the API is in Python?
That's where
%(https://github.com/hamishcunningham/pi-tronics/blob/master/simbamon/mopicli,
^mopcli^) comes in, which is a command-line interface to the Python API. This
script provides convenient methods for the daemon to use, or for Pi users to
query and configure the board, or for our configuration utility -- which by
amazing coincidence is described next.

To see what the beast can do, ask it for help by typing ^sudo mopicli -h^;
you'll get something like this:

%<
Usage: mopicli [-h] [options]
Version 0.2, API 0.2

Miscellaneous:
  -i          I2C bus (default: 1)
  -fv         Firmware version
  -sn         Serial number
  -h          Display this message

Status:
  -s          MoPi status word
  -sv         Verbose status
  -v          Current battery voltage in mV
  -v1/-v2     Battery #1/#2 voltage in mV

Read configuration options:
  -rc         Combined battery #1 and #2 configuration
  -rc1/-rc2   Configuration of battery #1/#2
  -rpon       Power on delay
  -rs         Shutdown delay

Write configuration options:
  -wc mV mV mV         Combined battery #1 and #2 configuration
  -wc1/-wc2 mV mV mV   Configuration of battery #1/#2
  -wpon seconds        Power on delay seconds
  -ws seconds          Shutdown delay seconds

All options may be used simultaneously. When doing so, they execute in the
  order they are listed in in this help message. However, only one of each may
  be used.
%>

As easy as pie.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Configuring Your Power Supplies

Not quite so easy is choosing the correct voltage settings for different
battery chemistries and different combinations of cells (not to mention other
types of power supply). In each case MoPi needs to know:

- what is the approximate voltage that the battery will supply when fully
  charged
- what is the point at which we're getting low on charge (and may expect to
  run out within a few minutes or so)
- what is the minimum safe discharge voltage

The mid-point between the first two voltages is is the conventional definition
of what a good level of charge is, so that's where we swap between lighting up
our RGB led in blue and lighting it in green. When we reach the low charge
point we turn the LED red, and when we reach the minimum safe discharge
voltage (or the minimum safe operating voltage if that is higher) then we
initiate shutdown.

Let's look at each of these values in more detail:

- _Fully-charged voltage_. This is equal to the fully-charged voltage of each
  cell in the battery pack multiplied by the number of cells. Like most things
  with batteries, it varies according to battery chemistry -- e.g. an Alkaline
  cell generates 1.5V; a NiMH 1.2V; a LiIon 3.7V.
- _The low charge level_. When you record the voltage delivered by a battery
  over time, most of the curves exhibit a knee shape. Before the knee voltage
  drop is reasonably slow; after the knee if drops much more sharply. We need
  to try and warn the user around the knee point, so that they have enough
  time to replace the battery before it drains completely, but not so much
  time that there is still lots of usable charge left.
- _Minimum safe discharge voltage_. This applies to all rechargeable
  batteries. If we discharge below this level, then the capacity to recharge
  will be impared. This makes it a very important factor in battery life for
  the long term, and one which we've done a lot of work to model and adapt to.
  (Ever wondered why the rechargeables that you put in your alarm clock or
  torch lasted such a short time? Most devices have no way of knowing about
  the minimum discharge level for the particular chemistry you're using!)
- _Minimum safe operating level_. MoPi uses a sophisticated microcontroller to
  analyse battery behaviour, control its LEDs and deliver data to the software
  suite running on the Pi. If the supply voltage to MoPi falls below a certain
  level (around 6.2V) then the microcontroller may terminate, or even start to
  behave unpredictably. It is very important to trap rapid voltage drop before
  it reaches this point.

To deal with all these considerations, the current version of the software
stores these values:

%<
        TYPE         CELL/FULL  MIN

  1     non-battery     9.0     6.2
  2     NiMH            1.2     0.95
  3     Alkaline        1.5     0.8
  4     Lead Acid       2.0     1.58
  5     Lithium Ion     3.7     3.0
  6     LiPo            4.2     3.0
  7     NiCd            1.2     1.1
%>

When we know what chemistry we're dealing with, and how many cells, we can
then make good guesses about where the four levels above should fall. But how
do we know what the chemistry is? Two ways:

- We have two built-in defaults, one for 8 NiMH cells (which is the battery
  pack that we're supplying to backers who requested one), and one for 8
  Alkaline non-rechargeables. The former is what MoPi will assume when running
  out of the box; the latter is activated by removing the on-board jumper
  provided for the purpose%footnote(Configuration provided by the user
  overrides the jumper for the current power cycle -- and beyond, when
  SimBaMon is running as the daemon will persist the config values. The
  firmware reads the jumper at each power up and initializes the cut-off
  points with Ni-MH or Alkaline values.).
- You tell us! To this end we have developed a configuration UI on the Pi,
  which is the last piece in our four part software puzzle.

The configuration UI uses the same tools as the Raspberry Pi's utility
(^raspi-config^), so it should be simple and familiar, and it can be used over
all types of connections (including remote login with ^ssh^). Here's a
screenshot or three:

%image(images/mopi/config-01.png, MoPi Config UI 1, 650)

_The main entry screen._ %br %br

%image(images/mopi/config-02.png, MoPi Config UI 2, 650)

_Configuring one of the power supplies, battery chemistry._ %br %br

%image(images/mopi/config-03.png, MoPi Config UI 3, 650)

_Getting status data (there's lots more in the newest version!)._

Dive into
%(https://github.com/hamishcunningham/pi-tronics/blob/master/simbamon/mopi,
the source code here).

And now you know more about batteries than you ever wanted to -- just like me!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Monitoring

As you can imagine, figuring out how all this stuff is working and identifying
bugs and incorrect behaviour is quite a challenge. Luckily we have some great
tools to help us, one of which is %(https://mmonit.com/, Monit). This little
gem is itself a daemon, and it has facilities for one thousand and one
different types of monitoring task. You can listen to your webserver and
restart it if it fails, or check the general load of the machine you're
running on, or -- in our case -- check that the SimBaMon service is running,
and if not start it up.

To use it, all we need to do is ^sudo apt-get install monit^ in the usual way,
then edit ^/etc/monit/monitrc^. This is the config we're using to monitor
SimBaMon on one of our test rigs:

%code(lang=bash)<
###############################################################################
# monit config for simbamond, from /etc/monit/monitrc #########################

# monitoring UI (serve on port 8888 and allow connections from one IP address)
set httpd port 8888 and
  allow 192.168.1.111

# general system status
check system mopi-15
  if loadavg (1min) > 4 then alert
  if loadavg (5min) > 2 then alert
  if memory usage > 75% then alert
  if swap usage > 25% then alert
  if cpu usage (user) > 70% then alert
  if cpu usage (system) > 30% then alert
  if cpu usage (wait) > 20% then alert

# monitor simbamond
check process simbamond with pidfile /var/run/simbamond.pid
  start program = "/usr/sbin/service simbamond start" with timeout 60 seconds
  stop program  = "/usr/sbin/service simbamond stop"
  restart program = "/usr/sbin/service simbamond restart" with timeout 60 seconds
  if cpu > 60% for 2 cycles then alert
  if cpu > 80% for 5 cycles then restart
  if totalmem > 200.0 MB for 5 cycles then restart
  if children > 250 then restart
  if loadavg(5min) greater than 10 for 8 cycles then stop
  if 3 restarts within 5 cycles then timeout
  group mopi
###############################################################################
%>

You can then see what's going on by either or both of

- ^cat /var/log/monit.log^ (^grep simbamon ...^ is also useful)
- pointing your browser at ^\http://my-pi-ip-address:8888^ (if you need to
  find your IP address various methods are %(/pages/blinkip.html, discussed
  here))

This is great for keeping check on things during load testing (particularly
heavy loads which have a tendency to cause odd corner case bugs to trigger),
but it is also a great tool for maximising service availability -- the
configuration code above will restart SimBaMon within a couple of minutes
should it ever crash, for example.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#simbamon
%2 SimBaMon: a Simple Battery Monitor daemon

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%3 Design Notes

There are a variety of ways that laptops communicate with and control their
batteries, including the
%(http://batteryuniversity.com/learn/article/inner_workings_of_a_smart_battery,
Smart Battery specification) (which often uses SMBus, a variant of the I2C
interface that the Pi supports). In Linux the resultant data feed is then
modelled using a power management abstraction (of which ACPI is the most
recent) and manipulated using a driver specific to the battery in use.

Sounds like a good idea? Yes, in the abstract, but implementing a new driver
is quite a job --
%(https://github.com/torvalds/linux/blob/master/drivers/acpi/battery.c, here's
one) that runs to 1200 lines of C code, for example. It is also not clear how
to do this when we have the ability to plug in batteries of different types,
which is something we really wanted to support.

What to do?

If in doubt, take the simple option. All Linux systems share the concept of a
_daemon_, which is a system-level service which gets run during operating
system startup. It is quite easy to implement a battery monitor daemon that
listens on the Pi's GPIO pins for level changes signalled by the MoPi
microcontroller board. The daemon then makes entries in the standard system
logs as a simple way to share data with other subsystems, and can be
configured to send a warning message to all users if levels are low. Best of
all, the daemon can easily shut down the Pi cleanly before the regulator
voltage gets too low for reliable operation.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%3 Implementation

This section gives more detail of the implementation of the SimBaMon battery
monitoring daemon. It is designed for the MoPi boards, but should be quite
easily reusable for other battery power projects. SimBaMon is an open source
Linux daemon for

- monitoring battery levels (on the Pi this is done via
  %(http://wiringpi.com/the-gpio-utility/, the ^gpio^ command))
- sending warning messages to the user if the battery is low
- shutting down cleanly at critical battery levels
- managing a power supply on/off switch
- writing relevant data to the system logs

You can find
%(https://github.com/hamishcunningham/pi-tronics/tree/master/simbamon,
the source code) on GitHub. The core of the daemon is defined in three files:

- ^/etc/simbamon.conf^    -- configuration data
- ^/usr/sbin/simbamon^    -- the daemon itself
- ^/etc/init.d/simbamond^ -- an interface to the ^init^ subsystem that Linux
  uses to manage daemons (amongst other things)

The last of these, ^simbamond^, is used by the operating system to start and
stop SimBaMon at boot or shutdown time, and can be used to control the daemon
manually when required. For example this command will stop the daemon:

%code(lang=Bash)<
sudo service simbamond stop
%>

The configuration file, ^simbamon.conf^, defines a set of states in which the
monitor will take some action:

%code(lang=Bash)<
POWER_OFF=1     # the user has pressed the power button, shutdown now
BAT_SHUTDOWN=2  # the battery is just about empty, shutdown now
BAT_CRITICAL=3  # the battery level is critically low, shutdown shortly
BAT_WARNING=4   # the battery is low, warn the user
BAT_FULL=7      # the battery is full
%>

The MoPi microcontroller supplies these states via the Raspberry Pi's
%(http://en.wikipedia.org/wiki/I%C2%B2C, I2C bus) (and also sets on-board
indicator LEDs accordingly). The core of SimBaMon, a shell script that lives
in ^/usr/sbin/simbamon^, implements an infinite loop that checks the levels
being reported over GPIO every few seconds and takes any necessary action. The
^wall^ command is used to send messages to any user currently logged in.

Here's a condensed version of the main loop (error checking, debug logging and
other details omitted):

%code(lang=Bash)<
while :
do
  # loop indices
  i=$(( ${i} + 1 )); j=$(( ${j} + 1 ))

  # get MoPi status
  MOPI_STATUS="`mopicli -nl -s`"

  # action states (shutdown or warn)
  if s_forced_shutdown "$MOPI_STATUS"
  then
    wall <<< "${NAME}: power off requested: shutting down now!!!"
    logger "${NAME}: shutting down (POWER_OFF; ${MOPI_STATUS})"
    eval "$SHUTDOWN"
  elif s_bat_critical "$MOPI_STATUS"
  then
    wall <<< "${NAME}: battery empty: shutting down now!!!"
    logger "${NAME}: shutting down (BAT_SHUTDOWN; ${MOPI_STATUS})"
    eval "$SHUTDOWN"
  elif s_bat_low "$MOPI_STATUS"
  then
    if [ $PREV_WARNING -eq 0 -o $(( $i - $PREV_WARNING )) -ge $WAIT_LOOPS ]
    then
      PREV_WARNING=$i
      wall <<< "${NAME}: ${LMESS} is low! connect new battery or shut down"
      logger "${NAME}: BAT_WARNING (${MOPI_STATUS})"
    fi
  fi

  # routine log messages
  [ "$DEBUG" = on -o ${j} -eq ${LOG_INTERVAL} ] && \
    logger "${NAME}: ${LMESS} is ${MOPI_STATUS} at `pdate` (i=${i})" && j=0

  # take a break
  sleep ${MONITOR_FREQUENCY}
done &
%>

Here is the
%(https://github.com/hamishcunningham/pi-tronics/blob/master/simbamon/simbamon,
current version of the code).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#installing
%3 Installing SimBaMon

The %(http://www.raspberrypi.org/archives/tag/alex-bradbury, Raspbian
maintainers) have been kind enough to include SimBaMon in their repository, so
you can just do this (as %(#quick-install, noted above)):

%code(lang=Bash)<
  sudo apt-get install simbamond
%>

Our software is also available from an
%(https://launchpad.net/~hamish-dcs/+archive/pi-gate, Ubuntu Personal Package
Archive) (PPA). (The Ubuntu infrastructure doesn't currently work for binary
Pi packages, but SimBaMon and the rest of the MoPi suite is implemented in
script (shell and Python), so we're ok in this case.)%footnote(The main
archive (for stable releases) is at
https://launchpad.net/~hamish-dcs/+archive/pi-gate with a development snapshot
archive at %(https://launchpad.net/~hamish-dcs/+archive/pi-gate-snapshots).)
To install from this archive:

*1.* Add this line to /etc/apt/sources.list:

%code(lang=Bash)<
deb http://ppa.launchpad.net/hamish-dcs/pi-gate/ubuntu precise main
%>

You can use a text editor (e.g. nano) to do this, or paste this one-liner into
a terminal prompt:

%code(lang=Bash)<
echo deb http://ppa.launchpad.net/hamish-dcs/pi-gate/ubuntu precise main |sudo tee -a /etc/apt/sources.list
%>

*2.* Import the %(http://www.gnupg.org/, GPG) encryption key from Ubuntu so
that the Pi can verify the package's validity:

%code(lang=Bash)<
sudo apt-key adv --recv-keys --keyserver keyserver.ubuntu.com --recv-key 6C12C1CF
%>

*3.* Update your list of available packages (this may take a couple of
minutes):

%code(lang=Bash)<
  sudo apt-get update
%>

*4.* Install the package:

%code(lang=Bash)<
  sudo apt-get install simbamond
%>

And that's it!

Note: the above gets you the most recent stable release; if you want to live
on the edge, you can get more recent experimental builds by adding the
snapshot PPA to your sources list, e.g.:

%code(lang=Bash)<
echo deb http://ppa.launchpad.net/hamish-dcs/pi-gate-snapshots/ubuntu precise main |sudo tee -a /etc/apt/sources.list
%>


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#howitworks
%1 How it Works: the Hardware

The MoPi circuitry consists of two parts: a single-chip microcontroller and a
five volt switching mode regulator. The microcontroller (with embedded
firmware) implements all the functions related to voltage level monitoring,
level signalling (via the LEDs and the GPIO interface), and on/off switching
of the +5V supply to the Pi. Battery voltage levels are measured using the
built-in microcontroller ADC%footnote(ADC: Analogue to Digital Converter.).

The schematic looks like this:

%image(images/mopi/schematic.png, An early MoPi schematic, 500, 292)

Two yellow LEDs are positioned next to the twin power pack inputs (screw
terminals), and indicate their status (blinking when either voltage is
critically low). The overall voltage level of both power inputs is indicated
by one RGB (three colour) LED and is also sent to the Raspberry Pi over the
I2C bus. The 5 volts to the Pi is generated by a highly efficient switch mode
voltage stabiliser, driven by the microcontroller. An open source daemon
running on the Pi listens to the I2C signal, informs the user of low battery
levels and shuts the Pi down cleanly when levels are critically low (or when
the power switch is pressed, or a delayed shutdown counter expires).

To start the 5V generator the power button should be pressed and held for 2
seconds. The microcontroller checks the voltage level of the attached battery
packs and if it is above the defined operating threshold, it switches the
stabiliser on to generate 5V for the Pi. The yellow LED for the battery (or
other) power input lights up, and the RGB LED lights up blue when the battery
pack is fully charged (or green if the voltage level is within the acceptable
operating range). The current voltage level is also accessible to the SimBaMon
daemon on the Pi via I2C.%footnote(Prior to version 4 a three-bit coded
voltage level is sent to the Pi over GPIO using %(http://wiringpi.com/,
WiringPi) pins 4, 5 and 6 (physical pins 16/18/22).). During operation, the
microcontroller continuously monitors the voltage level, and when it falls
beneath a safe level it switches the RGB LED to red. Simultaneously the yellow
LED for the low battery starts flashing, indicating that the pack needs
replacement.

%%% YOUTUBE MOPI BOARD CLIP HERE

Then the daemon SimBaMon on the Pi gets a low battery signal and informs the
user that they should either plug in another supply or shut down (again by
pressing the power button for 3 seconds). If nothing changes and the battery
continues to discharge down to a critical level, then the RGB LED starts
flashing red and MoPi forces a shutdown. If the user wishes to continue to
work and connects a new, charged battery pack (or other supply) to the second
connector within 30 seconds then the new battery will prevent the shutdown,
and the RGB LED will switch back to blue or green. The new input's
corresponding yellow LED will light up. The user can then remove the old
battery pack for charging.%footnote(Note: a flashing yellow LED for a low
supply will not reset until that supply has been disconnected for a minute or
so and then replaced with a good supply.)

Behaviour has to be adjusted for multiple battery chemistries; this is done
within the microcontroller firmware and can be configured from the Pi. MoPi
has two default discharging profiles pre-programmed -- one for NiMH
rechargeable batteries and one for ordinary Alkaline batteries. Out of the box
the NiMH profile is active; to choose the Akkaline profile, remove the small
jumper located on the under side of the board. The jumper applies to both
power inputs. The state of the jumper can be overridden via configuration from
the Pi, separately for each one of the power inputs. 

MoPi can be used as a UPS (Uninterruptible Power Supply). If the Pi is powered
over its 5V micro-USB socket and that power drops Pi while MoPi is active, the
supply fails over transparently, allowing the Pi to continue work
uninterruped. Note though that if the battery supply drops to critical level
SimBaMon will shut the Pi down. We're working on various circuits that work
around this issue.
%%% TODO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#measures
%1 Testing

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 The Longer-Lasting Snack

So, how long will the batteries last?

My first test was a Model B Pi with almost no load (USB keyboard and mouse;
monitor attached over HDMI but switched off after starting the test; no
network or other peripherals). Using eight rechargeable Duracell AA NiMH 2400
mAh batteries (like
%(http://www.amazon.co.uk/Duracell-Rechargeable-Accu-2400-Batteries/dp/B0031OE6LG/ref=sr_1_2?ie=UTF8&qid=1375768484&sr=8-2&keywords=duracell+nimh,
these ones)) the Pi ran for 9 hours 31 minutes. Not bad! Especially when you
consider that the MoPi regulator supports hot-swap of new charged packs --
this looks very viable for mobile Pi applications of all shapes and sizes.

For comparison I set up the same rig with a USB battery pack from RS
(%(http://uk.rs-online.com/web/p/power-banks/7757508/, this one), a 5200 mAh
Lithium polymer model). The results were remarkably similar, with the RS pack
lasting for 9 hours and 21 minutes.

Since then we've conducted 101 different tests. There are two key factors in
battery life: *1.* Model A vs. Model B; *2.* the peripherals. To summarise:

- You can expect a Model A to get around double the life of a Model B.
- What you connect to the Pi makes a huge difference. For example: WiFi is a
  power hog: halve your expected battery life if you're using it. An
  accelerometer, in contrast, is cheap: e.g. %(http://www.piborg.com/xloborg,
  XLoBorg) won't reduce your running time by much at all.

You can also connect two battery packs to MoPi and get double the running
time.

%%% TODO more test results


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Methods in the Madness

Most of our testing used external power supplies to make the development
cycles faster. (Well, would _you_ want to add "wait for the batteries to
discharge" to every edit/compile/test loop?!) I'm writing this post next to a
large humming monster:

%image(images/mopi/test-rigs/sofia-20140421-154603-500.jpg, Test Rig, 500)

The Pi is drawing 170 mA; MoPi is getting 11.9 volts from the PSU. The PSU
connects up to one of MoPi's supply inputs using a couple of re-purposed panel
pins:

%image(images/mopi/test-rigs/sofia-20140421-113148-500.jpg, Test Rig, 500)

Mission control (helicopter not strictly necessary):

%image(images/mopi/test-rigs/sofia-20140421-154651-500.jpg, Test Rig, 500)

%%% %image(images/mopi/test-rigs/sofia-20140421-113213-500.jpg, Test Rig, 500)
%%% %image(images/mopi/test-rigs/sofia-20140421-154556-500.jpg, Test Rig, 500)
%%% %image(images/mopi/test-rigs/sofia-20140421-113123-500.jpg, Test Rig, 500)
%%% %image(images/mopi/test-rigs/sofia-20140421-113138-500.jpg, Test Rig, 500)

We've also got a flash new PSU down at the workshop:

%image(images/mopi/test-rigs/workshop-20140409-153037-500.jpg, Test Rig, 500)

%image(images/mopi/test-rigs/workshop-20140409-153052-500.jpg, Test Rig, 500)

And here's Fred after I just showed him the bill:

%image(images/mopi/test-rigs/workshop-20140409-153131-500.jpg, Test Rig, 500)

While we're showing my snaps, here's one of my absolute favourite bits of kit
ever:

%image(images/mopi/test-rigs/workshop-20140409-153029-500.jpg, Test Rig, 500)
%%% %image(images/mopi/test-rigs/workshop-20140409-153021-500.jpg, Test Rig, 500)

This multimeter has been running reliably for 30 years! Ok, at some point I
couldn't get the batteries any more, so I had to bodge up a container for a
different size, but apart from that it has been pretty much perfect. I plugged
it into our new PSU, dialed up 6.2 volts and hey presto! The meter and the PSU
agreed 100%. Can I marry my multimeter?

We've got a new shiney one too, but the romance just isn't there:

%%% %image(images/mopi/test-rigs/workshop-20140409-153039-500.jpg, Test Rig, 500)
%image(images/mopi/test-rigs/workshop-20140409-153043-500.jpg, Test Rig, 500)

In early testing we often reached states that caused error conditions of one
sort or another on the Pi. For example:

- the green indicator LED repeatedly blinks three times when the ^loader.bin^
  bootloader file is not present -- in our case this was because a hard
  power shutdown caused corruption of the SD card
- the red power indicator LED may blink if the battery charge is very low and
  it is failing to drive the Pi (and if the microcontroller is not properly
  shutting down the regulator)

In cases like these the Embedded Linux wiki page on
%(http://elinux.org/R-Pi_Troubleshooting, RPI troubleshooting) is your friend!
Another useful part of the Pi-oneer's toolkit is the excellent
%(http://www.raspberrypi.org/archives/4100, NOOBS) setup from the Pi
foundation, which makes it easier to restore your SD card after failures.

But inevitably the life of electronics prototyping brings its fair share of
mystery -- why have my GPIO monitoring pins all gone low, all of a sudden,
when the indicator LED and the microcontroller still work? Cue much head
scratching and serious faces. Followed by a session with the debug header and
the diagnostics rig on the microcontroller -- and it turns out that a single
page of memory (which happenned to contain the code running the IO pins) has
been wiped, presumably by power fluctuations at the low battery state. Time to
add some more diodes!

And here's a typical gotcha:

- Step 1: have the bright idea of reusing the _battery totally empty_ state
  for the _shutdown button pressed_ state.
- Step 2: implement the code changes in the daemon and install. Reboot.
- Step 3: oops, my Pi just shut down as soon as it started. Hmmm.
- Step 4: oh yeah, that's also the default state of the GPIO pins when the
  MoPi rig isn't connected. Ah. That means that my Pi is going to shutdown
  every time I start it up. And Lubo just took the prototype boards back to
  the lab. Um. Looks like the _Donkey of the Day_ award is coming my way
  again.
- Step 5: waste half an hour remembering how to mount the SD card read-write
  on another machine and manually editing the daemon.

We learn from our mistakes -- that's why I make as many as possible.

Finally, the current author has found it useful to run around in circles,
screaming and shouting. (It doesn't fix the electronics, of course, but if
you're lucky it generates sympathy in those around you, or at least a desire
on their part to give you a beer to shut you up.)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#wild
%1 In the Wild: Applications

Want to strap a hackable GoPro-type cam to your skiing helmet? Or make a
Wii-type remote and splash virtual paint onto your devices? Or measure
atmospheric pollution in the garden with the AirPi sensor kit? The Raspberry
Pi is a great platform for these types of applications, but you'll need a
mobile power supply when you get out and about away from the wall socket.

%image(http://pi.gate.ac.uk/static/images/pibrush/thumbs/art/1379031321.jpg, Number 1)

If you've been following The Story of Pi these last couple of years you'll
have come across 1001 power supplies -- from batteries to solar panels, from
car connections to water turbines. The Pi was designed to give a boost to
science and technology education, and it has already made a huge impact --
here in the UK, for example, we have a shiney new computing curriculum in the
works. There a whole load of reasons why we need to *educate our kids about
technology*, and how technology can help them cope with the challenges that
the future holds. And not just any technology -- the Pi has a low carbon
footprint and is made in the EU.

The MoPi Kickstarter offered three Pi outdoor experimenter kits to help teach
the links between technology, climate, wildlife and the like:

- Outdoor Adventurer Kit
- Outdoor Experimenter Kit (Light)
- Outdoor Experimenter Kit (Light and Air)

We'll detail them here to give a flavour of the applications of the thing, but
really the sky's the limit: every mobile Pi project has a place for MoPi.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Outdoor Adventure Kit

The base level kit has everything you need to get out and about: a Raspberry
Pi Model B, case, SD card, and a MoPi board with NiMH batteries, holder and
charger (and a wall supply for when you get home!).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Outdoor Experimenter Kit (Light)

This kit has all of the previous one, plus the Raspberry Pi camera module (day
or night versions). Ideal for all types of outdoor motion-sensing and
photography projects. If you haven't tried the excellent
%(http://www.raspberrypi.org/camera, Pi camera yet) here are a couple of
examples:

Forest Gump came by the office when we were testing an early battery-powered
camera rig (a hackable "GoPro"?!):

%(images/mopi/gump2.jpg,
%image(images/mopi/gump2-500x375.jpg, Forest Gump, 500, 375))

The next olympic downhill ski champion straps a Pi cam to his head:

%(images/mopi/vladi-skiing-rig-1.jpg,
%image(images/mopi/vladi-skiing-rig-1-300x400.jpg, Vladi skiing, 300, 400))

%%% YOUTUBE SKIING CLIP HERE

Here's the camera rig:

%(images/mopi/ski-cam.jpg,
%image(images/mopi/ski-cam-500x343.jpg, Vladi skiing, 500, 343))

People have done all sorts of stuff with these cameras -- from videoing Teddy
Bears in the stratosphere to night filming wildlife -- the educational
opportunities are obvious.

Where do you want to use yours?!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Outdoor Experimenter Kit (Light and Air)

If you watch the film %(http://chasingice.co.uk/, Chasing Ice) you can't fail
to be amazed when a vast chunk of glacier the size of Manhattan suddenly
disintegrates before your eyes. What are the climate changes that have
triggered these massive events? How do they play out in the air we're
breathing? How do you measure atmospheric conditions, and what science can we
use to explain changes in those conditions?

Meet %(http://airpi.es/, AirPi), a brilliant Pi-based atmospheric monitoring
kit that ran a crowdfunding campaign in 2013 and started shipping in the
autumn. The *Outdoor Experimenter Light and Air Kit* includes an AirPi with
the mobile rig, all set to get out and about measuring temperature, relative
humidity, air pressure, light levels, smoke, and the concentrations of the
harmful gas pollutants carbon monoxide and nitrogen dioxide, and plotting the
results direct to a webserver running on the Pi.

Here's %(http://airpi.es/, the AirPi board), sensor and indicator set:

%(images/mopi/air-pi-2022x1317.jpg,
%image(images/mopi/air-pi-500x326.jpg, The AirPi Kit, 500, 326))

And here's one we built up on a breadboard:

%(images/mopi/air-pi-breadboard.jpg,
%image(images/mopi/air-pi-breadboard-500x375.jpg, AirPi on a Breadboard, 500,
375))

From version 3 MoPi uses a different set of GPIO pins in order to avoid
conflicts with AirPi (thanks Tom Hartley, creator of AirPi, for his help with
this).

We've done %(/tag/airpi.html, a lot of work with AirPi) and beefed up its
software offering a bit -- which Tom is going to include in the next official
distribution.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#batteries
%1 Batteries, Holders and Chargers

Here are links to some of the batteries, battery holders and chargers that
we've been testing MoPi with:

From %(http://rs-online.com/, RS Components):
- %(http://uk.rs-online.com/web/p/aa-rechargeable-batteries/6170773/,
  RS AA NiMH battery, 1.2V 2600 mAh)
- %(http://uk.rs-online.com/web/p/battery-chargers-aaa-aa-c-d-9-volt/0383241/,
  AA/AAA charger 250 mA)

From %(http://uk.farnell.com/, Farnell):
- %(http://uk.farnell.com/multicomp/bt00839/battery-holder-8xaa-pk5/dp/3829583,
  x8 AA battery holder)
- %(http://uk.farnell.com/duracell/5000394065710/battery-nimh-1-2v-2400mah-pk4/dp/1330278,
  Duracell AA NiMH 2400 mAh 4-pack)
- %(http://uk.farnell.com/energizer/635429/battery-precision-ni-mh-aa-2400mah/dp/2075715,
  Energiser AA NiMH 2400 mAh 4-pack)
- %(http://uk.farnell.com/ansmann/5107343-uk/charger-basic-4-plus/dp/1294240,
  x4 AA battery charger)

From %(http://maplin.co.uk/, Maplin):
- %(http://www.maplin.co.uk/extra-high-capacity-nimh-rechargeable-battery-value-packs-46414,
  NiMH AA 2400 mAh 8-pack)
- %(http://www.maplin.co.uk/hybrid-the-next-generation-rechargeable-battery-219932, 
  Hybrid AA 2100 mAh 4-pack)
- %(http://www.maplin.co.uk/batteries-and-power/batteries/battery-chargers, AA
  chargers)
- %(http://www.maplin.co.uk/aa-size-battery-holders-31427, x8 AA battery
  holder RK44X)

%%% TODO add RadioShack


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#other
%1 Other Directions

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 A Possible Charging Circuit

One feature that we didn't manage to get sufficient backing for was battery
charging. This feature would be a great addition to MoPi, but it turns out to
be pretty difficult :-( In fact, dealing with lots of different chemistries
may not be possible at all on a tiny device like MoPi. (Most manufacturers of
charging ICs only support one chemistry per chip, for example, and some only
support charging a single cell per chip! Many chargers also rely on having a
temperature sensor in physical proximity to the batteries
themselves.)%footnote(We like our backers. We'd rather not incinerate them if
not completely necessary.) The other challenge is that we've got a really
small surface area to work with on the PCB.

Still, a number of our backers want to use MoPi with a charger (e.g. to charge
batteries from solar panels during the day and then run on batteries
overnight), so we've been working on a configuration with an external charger.
For example, here's how we think a UPS configuration with charging could look:

%(https://www.circuitlab.com/circuit/dsguk8/ups-configuration/,
%image(images/mopi/ups-with-charger.png, UPS with charger, 540, 405))

We haven't tested this yet, but it _should_ work ;-)

There are a number of potential gotchas in this type of circuit. For example,
when the mains power drops, the Pi must be powered pretty much instantly in
order to avoid triggering a reboot. There are no big capacitors on the Pi's
PCB to buffer its consumption of 300-500 mA without power. To deal with this
requirement we need MoPi to be always on and monitoring the Pi's 5V feed, even
when that feed isn't being supplied by MoPi itself. (This doesn't waste much
power as our microcontroller is very efficient.) When MoPi sees the 5V rail
start to fall the controller immediately enables its 5V stabilizer, taking
over supply of power to the Pi.

In the circuit above, when there is mains, the charger is generating e.g. +12V
DC and the relay's coil is energized. The contact is switched to the normal
open position and is passing +12V to charge the batteries. When mains drops,
the relay is switching to the normal closed position and charging will stop.
MoPi is powered all the time -- and so, we hope, is the Pi. (What does the
diode do? When the +12V goes down, accumulated energy in the relay's coil must
be dissipated. The diode is shorting the coil to do that. Otherwise the
relay's contact will stay closed for a longer time.)

More on this when we get time to test it out in practice.

In the meantime we've been working on various solar options... Watch
http://pi.gate.ac.uk/ for updates.
%%% TODO


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Other Options

For voltage regulation another option is a UBEC%footnote(UBEC stands for
Universal Battery Elimination Circuit, which is rather a misnomer as they're
often used to regulate battery supplies. Hey ho.) -- a device popular with
radio-controlled aircraft people, and hence nice and light-weight, and also
fairly cheap, e.g.:
%(http://www.giantshark.co.uk/hobbywing-3amp-ubec-p-402342.html, this one),
%(http://www.modelaccessories.co.uk/hobbywing-3amp-ubec.html, this one) or
%(http://www.hobbyking.co.uk/hobbyking/store/uh_viewItem.asp?idProduct=28160,
this one). UBECs are switched-mode regulators, just like our MoPi regulator
board, so they don't waste power when converting high DC to 5 volt DC.

Some other useful links about Pi battery projects: on
%(http://www.raspberrypi-spy.co.uk/2013/02/running-a-raspberry-pi-from-6-aa-batteries/,
Raspberry Spy); on the
%(http://www.raspberrypiforums.com/forums/tutorials/article/17-how-to-portably-power-your-raspberry-pi-with-a-battery/,
Raspberry Pi Forums).

%(http://www.amazon.co.uk/Raspberry-Pi-Manual-practical-revolutionary/dp/0857332953/,
Gray Girling's Pi owners' manual) also has a good discussion about battery
supplies and their subtleties (and is generally an excellent investment for
the Pi enthusiast).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%1 Linux is Lovely

One of the great things about the Pi is that it runs a %(http://fsf.org/, free
and open source) software stack. This makes development so much easier --
and here's an example of why...

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Glitches in the Pi's I2C Bus

The I2C bus is a great way to ship data between the Pi and add-on boards like
MoPi. It is also a bit of a pig to get working: the CPU in the Pi has a
hardware bug that causes intermittent bad reads from the bus. Quoting
%(https://github.com/raspberrypi/linux/issues/254, Renata Wolff):

%"
The broadcom BCM2835 has a (hardware) bug in the I2C module.

The BCM implements "clock stretching" in a bad way:

Instead of ensuring a minimum "hightime" for the clock, the BCM lets the I2C
clock internally run on, and when it's time to flip the clock again, it checks
wether or not the clock has become high, and if it is low, it does a "clock
stretch". However if just in the few nanoseconds before this check the slave
releases the clock signal indicating it is ready for a new clock, the clock
pulse may become as short as 40ns. (that's the lowest I'm able to measure, and
that of course is quite rare). With a 100kHz (10 microseconds) I2C clock, the
"bad" moments to release the clock are 5 microseconds apart.
%"

(See also %(https://dl.dropbox.com/u/3669512/2835_I2C%20interface.pdf, Gert
van Loo's description here).) This took us a quite a few debug cycles to cope
with! Below some details of one of the methods used (the others involving lot
of sweating over a hot oscilloscope, trawling system logs and the like!).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Installing I2C

Now that MoPi uses I2C as its communication mechanism, we have to enable this
in the SimBaMon package. Here's how we do it%footnote(The key steps are
described in various places, including
%(https://learn.adafruit.com/adafruits-raspberry-pi-lesson-4-gpio-setup/configuring-i2c,
on Adafruit).):

- if i2c-tools isn't already installed, install it:
  - ^sudo apt-get install i2c-tools^
- (you might as well do the same with ^python-smbus^ for testing purpose)
- edit ^/etc/modules^ and add lines ^i2c-bcm2708^ and ^i2c-dev^
- edit ^/etc/modprobe.d/raspi-blacklist^ (if it exists) and comment out the
  line ^blacklist i2c-bcm2708^ (by adding a ^#^ at the start of the line)

(The ^postinst^ script in our Debian package for SimBaMon does all this for
you, by the way.)


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%2 Debugging with I2C Tools

The process of developing our interface involved hacking the ^i2c-tools^
package to play with the multi-byte read facility in the ^i2cdump^ command.
On a closed-source operating system, of course, you would be stymied at this
point. On Linux it is super easy :-)

Here's how to pull down the source code, rebuild and test:

- edit ^/etc/apt/sources.lst^ and add this line:
  - ^deb-src http://mirrordirector.raspbian.org/raspbian/ wheezy main contrib
    non-free rpi^
- then
  - ^sudo apt-get update^
  - ^mkdir i2c-tools^
  - ^cd i2c-tools^
  - ^apt-get source i2c-tools^
- then ^make^ will recompile (the tools are in the directory ^tools^)

Hey presto, I can hack away at the C code and get immediate feedback with
commands like ^sudo tools/i2cdump -y 1 0x0b i^ (where ^0x0b^ is MoPi's
designated I2C address -- the smart battery address)%footnote(For a revision 1
Pi -- the very early boards -- use ^0^ instead of ^1^.).
