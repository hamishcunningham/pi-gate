A Flood in the Basement

There's a poltergeist who lives in my basement. Either that, or I've had three
completely coincidental pipe failures in the space of a couple of years. The
last leak had such a high flow rate that if I hadn't wandered past in the
morning and wondered what that hissing noise was we would have had a brand new
swimming pool by the evening. The most worrying thing was that the leak came
from a pipe joint that was brand new a year ago (and not fitted by me, either,
but by a skilled professional%footnote(And not one called
%(http://sillof.com/images/Customs/gilliam/tg-B-harry.jpg, Harry Tuttle).)).

So I decided I needed a bit of long-term plumbing reassurance in the form of a
water alarm that will send me an SMS text message whenever things get wetter
than expected under the house. With a Pi and an alarm circuit like
%(#parent-alarm, our parent alarm) this turns out to be a nice project.

Materials used:
- as per the parent alarm, minus the pressure pad
- a simple mobile phone with USB cable, or a network-connection and an account
  on an SMS web service

The trick here is to find a way to sense the presence of moisture. As water
conducts electricity we can do this using a variation on one of our
%(#switches, switching circuits): we'll run a length of two-core wire through
all the areas where we expect flooding and strip each core so that a flood
would connect the two cores together.

To decide on the values for the circuit that we'll use to connect to the Pi,
we need to test the resistance of the water connections using a multimeter; it
turns out that we have something between 20k and 50k ohms when the bare wire
is immersed. When the wire is dry (hopefully the long-term average!) the
resistance will be infinite (like an open switch). We also should expect that
the wires may touch (if someone steps on them and presses them together, for
example), so we also have to cater for a 0 ohms resistance. To deal with these
possibilities we'll use a 1k limiting resistor and a 100k pull down resistor
like this:
%br %(https://www.circuitlab.com/circuit/at8v7f/water-sensor-raspberry-pi/,
%image(images/water-sensor-raspberry-pi.svg, water sensor, 500)) %br
Here's what happens in our three cases:
- When the wire is dry, R1 acts as an infinite resistance, and pin 11 (which
  we set in input mode) is pulled low via R2 and R3.
- When the wire is wet, R1's resistance will be some way lower than that of R3
  (the pull down resistor) and so pin 11 will be pulled high.
- If the wires are shorted R1's resistance will be close to zero, but we will
  not draw too much current from the Pi because of the presence of R2.

The code to read from our water sensor is very simple: ^gpio mode 0 in^ sets
things up, and ^gpio read 0^ takes a reading. When things get wet (or there's
a short circuit) the read statement will return 1; otherwise it will return 0.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#alarm-integration
%2 Hooking it all Together

Finishing off the flood alarm is a matter of combining the LED and buzzer
notification circuits with the water sensor just above. The breadboard looks
like this:

%image(images/bbd-flood-alarm-detail.jpg, final flood alarm breadboard, 500)

Here it is in context, with a fantastically expensive test rig consisting of a
length of bell wire to dip in a plastic box full of wet stuff:

%image(images/flood-alarm-context.jpg, final flood alarm context, 500)

Here's the complete circuit diagram:

%(https://www.circuitlab.com/circuit/vhp9ma/flood-alarm-raspberry-pi/,
%image(images/flood-alarm.svg, flood alarm, 850))

The software for the beast is a bit more complex than we've worked with before
-- it loops forever and takes care of sending an %(notipi.html, SMS
notification) when things get wet, etc.:

%<
#!/usr/bin/env bash
# flood-alarm.sh

# standard locals
alias cd='builtin cd'
P="$0"
USAGE="`basename ${P}` [-h(elp)] [-w(et)] [-d(ry)]\n
\twet and dry are for testing; normally we are run without options\n
\tand loop forever waiting for state changes on GPIO 2..."
OPTIONSTRING=hwd

# specific locals
WET=0
DRY=0
STATUS=none

# message & exit if exit num present
usage() { echo -e Usage: $USAGE; [ ! -z "$1" ] && exit $1; }

# process options
while getopts $OPTIONSTRING OPTION
do
  case $OPTION in
    h)	usage 0 ;;
    d)	DRY=1; WET=0 ;;
    w)	WET=1; DRY=0 ;;
    *)	usage 1 ;;
  esac
done 
shift `expr $OPTIND - 1`

# get started
echo Hello! no flooding today, we hope...

# set up the gpio pins
gpio mode 0 out # pin 0 is the buzzer and red led
gpio mode 1 out # pin 1 is the green led
gpio mode 2 in  # pin 2 is the water sensing circuit

# helpers for processing state changes
statusDry() {
  if [ $STATUS == wet ]
  then
    echo Becoming dry...
  else
    echo Staying dry...
  fi
  STATUS=dry
  gpio write 0 0
  gpio write 1 1
}
statusWet() {
  if [ $STATUS == dry ]
  then
    echo Eek! Becoming wet!
  else
    echo Bugger. Staying wet!
  fi
  STATUS=wet
  gpio write 0 1
  gpio write 1 0
}

# helper to send notifications when wetness persists
notifyFlooding() {
  DATE_TIME=`date '+%b %d %Y %T'`

  # send an SMS over the net
  PW=`cat flood-alarm-data-efs/bulksms.txt`
  SMS_STATUS=`./hc-sendbulksms.sh -u hamishcunningham \
    -p "${PW}" -n 447740149842 -m "Flooding in the basement? $DATE_TIME"`
  echo "BulkSMS says: ${SMS_STATUS}"

  # send an SMS over the phone
# TODO
}

# either do a state change (for debugging), or loop
if [ $DRY == 1 ]
then
  statusDry
elif [ $WET == 1 ]
then
  statusWet
else
  # after an alarm wait at least 30 mins before re-testing
  MIN_DELAY=30
  DELAY=${MIN_DELAY}
  while :
  do
    WET=`gpio read 2`
    if [ $WET == 0 ]
    then
      statusDry
      DELAY=${MIN_DELAY}
      sleep 1
    else
      # raise the alarm
      statusWet
      notifyFlooding
      echo Taking a break for ${DELAY} minutes...
      sleep ${DELAY}m

      # if it is still wet we want to sleep longer next time
      DELAY=`expr 2 \* ${DELAY}`
      if [ $DELAY -gt 1440 ] 
      then
        # max delay is 24 hours
        DELAY=1440
      fi
    fi
  done
fi
%>

And it works!


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%#alarm-build
%2 Building and Installing

Now, I want my breadboard for other things, and I want to box up the beastie
for installation in my basement, so the final step is to solder it all
together onto a permanent fixture -- in this case a piece of stripboard.

TODO the stripboard version installation
